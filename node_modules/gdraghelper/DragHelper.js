/*
    DragHelper.js
    -------------

    Provides a class to help dragging things with the mouse, using top-level window events so dragging Out-of-Bounds over an element will continue to work.

    Usage:
    - Create a DragHelper object
    - call dragStart on the object when you get a mouse down on the item you want drag support on
    - pass in two callbacks, one to handle mouse moves while dragging, and one when drag operation is over (mouse up)
    - both callbacks will get deltaX and deltaY as parameters.
    - units are in pixels, relative to where the drag started (drag start is 0, 0)

    This wil add a mouse mouse and mouse up event listener to the main window object.

    You can call getCursorPos on this object at any point to get the current cursor pos in window coordinates.

*/
export default class DragHelper {


  /**
   * Constructor for the DragHelper object
   * 
   * @param {Object} options - OPTIONAL; object with default options for this drag helper, like { usePointerEvents, scaleMultiplier }
   */
  constructor(options) {

    // define our default options
    const defaults = {
      usePointerEvents: false,
      scaleMultiplier: 1,
    };

    // apply our optional options
    options = (options===undefined) ? {} : options;
    this.options = {
      ...defaults,
      ...options
    };

    // Save the global mouse position so we can easily reference it
    this._mouseX = 0;
    this._mouseY = 0;

    // Save the start X/Y position of a mouse-drag so we can calculate deltaX/deltaY alter
    this._startX = 0;
    this._startY = 0;

    // Storage for the call back functions
    this._callBacks = [];

    // The state of weather or not a current drag is in progress
    this._isDragging = false;

    // true if we're on the first-fire of the move function
    this._firstMove = false;

    // pick which move event to add for our movement inputs
    // (pointermove vs mousemove)
    const moveEventName = this.options.usePointerEvents ? 'pointermove' : 'mousemove';

    // Set up an event handler so we always know the global mouseX and mouseY
    window.addEventListener(moveEventName, (event) => {
      this._mouseX = event.pageX;
      this._mouseY = event.pageY;
    });

    // Set up an event handler for mousemove to our custom dragMove function
    window.addEventListener(moveEventName, event=>this._onDragMove(event));

    // Set up an event handler for mouseup/pointerup/touch to our custom dragMove
    // note that we'll handle ALL of these, but only one will have effect because the first one
    // that is handled will set this._isDragging to false
    window.addEventListener('mouseup', event=>this._onDragEnd(event));
    window.addEventListener('pointerup', event=>this._onDragEnd(event));
    window.addEventListener('touchend', event=>this._onDragEnd(event));

  }


  /**
   * Returns the last recorded mouse position in the window as an object like {x, y}
   * @returns {Object} - basic 2d point object with X and Y
   */
  getCursorPos() {

    return {
      x: this._mouseX,
      y: this._mouseY,
    };
  }


  /**
   * Updates scaleMultiplier on our instance
   * 
   * @param {Number} scaleMultiplier - new value to multiply deltas by before calling callbacks
   */
  setScaleMultiplier(scaleMultiplier){
    this.options.scaleMultiplier  = scaleMultiplier;
  }


  /**
   * Sets up a drag operation with two callbacks for during the drag move & after
   * 
   * @param {Function} callBackFunctionMove - call back function for when the mouse moves during a drag operation
   * @param {Function} callBackFunctionEnd - call back function for when the mouse drag operation ends
   * @param {Number} scaleMultiplier - OPTIONAL; - provide a new scale-modifier, since this might change from when we were constructed
   * @returns {Number} the index of the latest call backs added to our array of callbacks *see not in function body
   */
  dragStart(callBackFunctionMove, callBackFunctionEnd, scaleMultiplier) {

    /*
      * This class originally assumed there could be multiple callbacks attached at once
      but in practicality, parallel drag operations at once is basically rare / impossible.

      Someday, should stop using arrays to store the callbacks.

      So essentially, the return value of this method is useless.
     */

    // handle optional parameter
    scaleMultiplier = (scaleMultiplier===undefined) ? this.options.scaleMultiplier : scaleMultiplier;
    this.options.scaleMultiplier = scaleMultiplier;

    // Save the initial position of the mouse when this is run, unless we're already dragging)
    if (!this._isDragging) {
      this._startX = this._mouseX;
      this._startY = this._mouseY;
    }

    // Save the callback function
    this._callBacks.push({
      onMove: typeof callBackFunctionMove === 'undefined' ? null : callBackFunctionMove,
      onEnd: typeof callBackFunctionEnd === 'undefined' ? null : callBackFunctionEnd,
    });

    // We are now dragging
    this._isDragging = true;

    // this will be set back false, if as soon as we get one move update
    this._firstMove = true;

    //return true since we were able to start dragging
    return this._callBacks.length - 1;

  } 


  /**
   * Stops all dragging call backs & sets our drag mode to false.
   * 
   * This replaces the old cancel call back which is deprecated.
   */
  dragStop(){

    // if we're current not dragging, just BTFO
    if(this._isDragging==false)
      return;

    // we can just call our private function, with no event object
    // because this will fire the on end callbacks & clear everything.
    this._onDragEnd();
  }


  /**
   * Handles mouse move at a window level
   * 
   * @param {Event} event - the JavaScript event object
   * @returns {Boolean} false is no current drag operation
   */
  _onDragMove(event) {

    // If we're not dragging, nothing to do here!
    if (!this._isDragging) return false;

    // Make sure the UI doesn't mess up thanks to HTML
    event.preventDefault();

    // if we're on the first move and we're using pointer-events instead of mouse events,
    // we need to set the initial positions now, because they would be wrong previously
    // (because pointer move wont run on iPad until pointer is also down)
    if(this._firstMove==true && this.options.usePointerEvents==true){
      this._startX = this._mouseX;
      this._startY = this._mouseY;
    }

    // Calculate the delta X and Y
    var deltaX = (this._startX - this._mouseX) * this.options.scaleMultiplier;
    var deltaY = (this._startY - this._mouseY) * this.options.scaleMultiplier;

    // Call the callback function with the delta data
    if (this._callBacks.length > 0) {

      for (var i = 0; i < this._callBacks.length; i++){

        if (this._callBacks[i].onMove != null){

          this._callBacks[i].onMove.call(null, deltaX, deltaY);
        }
      }// next i
    }

    // this will never be true again, until someone calls dragStart again
    this._firstMove = false;
  }


  /**
   * Handles when there is a mouse up on the window. If we're dragging, time to end the drag operation
   * 
   * @param {Event} event - the JavaScript event object
   */
  _onDragEnd(event) {
    
    // if dragging is already done, gtfo
    if(this._isDragging==false)
      return;

    // Calculate the delta X and Y
    var deltaX = (this._startX - this._mouseX) * this.options.scaleMultiplier;
    var deltaY = (this._startY - this._mouseY) * this.options.scaleMultiplier;

    // Call the callback function with the delta data
    if (this._callBacks.length > 0) {

      for (var i = 0; i < this._callBacks.length; i++){

        if (this._callBacks[i].onEnd != null){

          this._callBacks[i].onEnd.call(null, deltaX, deltaY);
        }
      }// next i
    }

    // Disable dragging
    this._isDragging = false;

    // Clear the call back functions
    this._callBacks = [];
  }


  /**
   * Clears our assigned callbacks.
   *
   * NOTE: this function is basically deprecated because we dont really need to support an array of callbacks anymore.
   *
   * To do: remove this.
   * @param {Number} id - index of callbacks to clear
   */
  cancelCallback(id) {
    console.warn('cancelCallback is deprecated');
    this._callBacks[id] = { onMove: null, onEnd: null };
  }

}
